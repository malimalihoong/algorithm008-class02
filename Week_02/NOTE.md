学习笔记
HshMap 采用数据+链表（或红黑树）形式存储数据，是一种非线程安全地数据结构。
实现Map接口，采用k-v键值对形式存储。默认初始长度为 1<<4 ,可通过手动设置长度赋初值，
但hashMap都会自动将初始值设置为2^n次方。方便用于对键值得hashcode计算，减少hash冲突。
V put(K key, V value):
api注释：如果hashmap中不存在当前存入的key值，则直接存入，如果存在则替换原来的值，
        判断key值是否存在的原则是采用hashcode(key)+ equals方法判断key唯一性。
hashmap中存值时，将k-v封装成Node数据类型， hashMap底层为Node<K, V>[] table;
1、判断hashmap长度是否合法，如果为空或为0，都将调用resize()方法进行数组长度扩容。
2、计算 hash(key) & table.length-1, 计算数组下标，如果为空，则创建新节点进行存入。
3、如果当前位置（oldNode）不为空，则判断如下：
    假设将存入值为newNode，调用hash函数和equals函数，比较新老节点的是否为相同的节点。
    如果为相同节点，则直接替换，
    如果当前数据位置为树结构存储，则调用putTreeVal api存入节点
    如果为链表结构：
        如果数组位置节点next指针指向是否为空，如果为空，则将新节点挂在
 数组位置当前节点之后，如果当前数据位置，链表长度大于等于7（阙值-1），则将链表转换成树结构存储。
        如果数组位置节点next指针指向``不为空，则，对比next指针指向的节点与当前存入的newNode节点
 是否相同（通过hash函数和equals函数），如果相同，则直接替换当前节点，
 4、在执行完步骤三后，节点已经插入到hashmap中，或在链表，或在树结构，或为单个元素（没有hash冲突）
    ，此时需要判断hashmap长度是否已达到之前初始化时的长度*0.75，如果达到的话就调用resize方法
    进行扩容计算。

扩容 resize()
 可以看到resize方法经历了以下步骤：
    首先获取hashmap已有的容量oldCap，判断oldCap是否大于Integer.MAX_VALUe,如果大于，则当前
    新容量newCap= Integer.MAX_VALUE;否则的话讲oldCap<<1, 扩大为之前的2倍。并且将满足扩容条件
    的阙值threadHold变量，扩大为原来的2倍。
    在设置好新数组的长度和扩容阙值后，由于数组长度的改变，每个元素hash所得数组下标也会发生变化。
    hashmap对原有元素数组下标的判断是如下进行的：
        遍历hashmap数组元素，判断每个数组位置元素存储结构（单个元素，链表，树）
        如果为单个元素，则对当前元素hash(key) & newCap-1,计算在新数组中的下标，存入。
        如果为树结构，则调用树操作，插入当前元素；
        如果为链表结构，hashmap采用两种方式进行数组元素的存放，先说结果：
            如果元素e.hash & oldCap == 0,则在获取到当前位置链表后，存储在原数组位置。
            如果元素e.hash & oldcap != 0,则在获取到当前位置链表后，存储在原数组位置+1的位置。
        这里有以下考虑，如果当前元素hash值与oldCap与运算结果为零，则与newCap-1与运算，结果为原数组位置，
        如果当前元素hash值与oldCap与运算结果不为0，则与newCap-1与运算结果为原数组位置+oldCap.
        
        原因在与hashmap长度默认为2^n，因此如果元素e.hash与olcCap与运算，结果取决于e.hash值中与olcCap中bit有效位的值的差异。
        如果为1，则结果为1， 否则结果为0.此时在与newCap-1，进行数组下标位置计算时，可观察到数组位置下标取决于e.hash & olcCap长度。
        
        hashmap扩容非线程安全，在于resize时，如果thread1 扩容到一半时，挂起，
        thread2进行扩容时，会产生循环链表。